import streamlit as st
import pandas as pd
import time
import hashlib
from datetime import datetime, timezone, timedelta



def build_horizontal_menu(memory, user_id):
    """Constr√≥i o menu horizontal no topo do aplicativo."""
    # Key √∫nica baseada no user_id para manter consist√™ncia
    unique_key = f"file_uploader_{user_id}"
    
    # Container para o menu horizontal
    col1, col2, col3 = st.columns([2, 3, 2])
    
    with col1:
        st.markdown("### üì§ Upload de Dados")
        
        # SOLU√á√ÉO: File uploader SEM customiza√ß√µes
        uploaded_file = st.file_uploader(
            "Selecione seu arquivo CSV",
            type=["csv"],
            accept_multiple_files=False,
            key=unique_key
        )
        
        # Debug: Mostrar estado do upload
        if uploaded_file is None:
            st.info("üìÅ Nenhum arquivo selecionado. Clique em 'Browse files' acima.")
        else:
            st.success(f"‚úÖ Arquivo carregado: {uploaded_file.name}")
    
    with col2:
        st.markdown("### üìä Hist√≥rico de Sess√µes")
        sessions = memory.get_user_sessions(user_id)
        if sessions and len(sessions) > 0:
            # Mostrar apenas as 3 sess√µes mais recentes em formato compacto
            recent_sessions = sessions[:3]
            session_options = []
            for session in recent_sessions:
                try:
                    created_at_str = session['created_at']
                    if 'Z' in created_at_str or '+00:00' in created_at_str:
                        created_at = datetime.fromisoformat(created_at_str.replace('Z', '+00:00'))
                        local_time = created_at.astimezone()
                    else:
                        created_at = datetime.fromisoformat(created_at_str).replace(tzinfo=timezone.utc)
                        local_time = created_at.astimezone()
                    
                    session_label = f"{session['dataset_name']} - {local_time.strftime('%d/%m/%Y %H:%M')}"
                    session_options.append(session_label)
                except Exception:
                    session_options.append(f"Sess√£o {session['id'][-6:]}")
            
            st.selectbox(
                "Sess√µes recentes",
                options=session_options,
                key="session_selector",
                label_visibility="collapsed"
            )
        else:
            st.info("Nenhuma sess√£o anterior")
    
    with col3:
        st.markdown("### ‚öôÔ∏è Configura√ß√µes")
        if st.button("üîÑ Limpar Sess√£o", use_container_width=True):
            st.session_state.clear()
            st.rerun()
    
    st.markdown("---")
    return uploaded_file


def build_sidebar(memory, user_id):
    """Constr√≥i a sidebar do aplicativo (mantido para compatibilidade)."""
    with st.sidebar:
        st.header("An√°lise EDA com IA")

        # Key √∫nica baseada no user_id para manter consist√™ncia
        unique_key = f"file_uploader_{user_id}"

        uploaded_file = st.file_uploader(
            "Fa√ßa o upload do seu arquivo CSV",
            type=["csv"],
            accept_multiple_files=False,
            key=unique_key
        )

        st.subheader("Hist√≥rico de Sess√µes")
        sessions = memory.get_user_sessions(user_id)
        if sessions:
            for session in sessions:
                try:
                    # Converte a string de data/hora para um objeto datetime com timezone UTC
                    # O formato esperado √© algo como '2025-09-26T22:26:00.000000+00:00'
                    created_at_str = session['created_at']
                    
                    # Verifica se j√° tem timezone (deve ter vindo do Supabase com +00:00)
                    if 'Z' in created_at_str or '+00:00' in created_at_str:
                        # Se j√° tiver timezone UTC, converte para objeto datetime com timezone
                        created_at = datetime.fromisoformat(created_at_str.replace('Z', '+00:00'))
                        # Converte para o fuso hor√°rio local do sistema
                        local_time = created_at.astimezone()
                        # Obt√©m o offset local formatado (ex: -03:00)
                        offset = local_time.strftime('%z')
                        offset_str = f"UTC{offset[:3]}:{offset[3:5]}"
                    else:
                        # Se n√£o tiver timezone, assume UTC e converte para local
                        created_at = datetime.fromisoformat(created_at_str).replace(tzinfo=timezone.utc)
                        local_time = created_at.astimezone()
                        offset = local_time.strftime('%z')
                        offset_str = f"UTC{offset[:3]}:{offset[3:5]}"
                    
                    st.info(
                        f"ID: ...{session['id'][-6:]}\n"
                        f"Dataset: {session['dataset_name']}\n"
                        f"Data: {local_time.strftime('%d/%m/%Y %H:%M')} ({offset_str})"
                    )
                except Exception as e:
                    st.error(f"Erro ao exibir sess√£o: {e}")
        else:
            st.write("Nenhuma sess√£o anterior encontrada.")

        st.subheader("Configura√ß√µes")
        st.info("Configura√ß√µes futuras aqui.")
    return uploaded_file


def display_chat_message(role, content, chart_fig=None, key=None, generated_code=None):
    """Exibe uma mensagem no chat."""
    execution_container = None
    results_container = None

    with st.chat_message(role):
        st.markdown(content)

        # Sempre exibe o c√≥digo se estiver dispon√≠vel (ANTES do gr√°fico)
        # O c√≥digo deve aparecer antes do gr√°fico para melhor UX
        if generated_code and role == "assistant":
            execution_container, results_container = display_code_with_streamlit_suggestion(
                generated_code,
                auto_execute=False
            )

        # Verificar se o gr√°fico existe e √© v√°lido antes de exibir
        if chart_fig and role == "assistant":
            try:
                # Verificar se o gr√°fico ainda √© v√°lido
                if _is_chart_valid(chart_fig):
                    # Gera uma chave √∫nica se n√£o foi fornecida
                    if key is None:
                        content_hash = hashlib.md5(f"{role}_{content}_{str(chart_fig)}".encode()).hexdigest()[:8]
                        key = f"chart_{role}_{content_hash}"

                    # Exibir o gr√°fico com verifica√ß√£o de erro
                    st.plotly_chart(chart_fig, use_container_width=True, key=key)
                else:
                    st.warning("‚ö†Ô∏è Gr√°fico n√£o est√° mais dispon√≠vel.")
                    st.info("O gr√°fico foi gerado anteriormente mas n√£o p√¥de ser restaurado.")
            except Exception as e:
                # Se houver erro ao exibir o gr√°fico, mostrar aviso
                st.warning(f"‚ö†Ô∏è Erro ao exibir gr√°fico: {str(e)}")
                st.info("O gr√°fico foi gerado mas n√£o p√¥de ser exibido.")

    return execution_container, results_container


def _is_chart_valid(chart_fig):
    """Verifica se um gr√°fico Plotly √© v√°lido e pode ser exibido."""
    try:
        if chart_fig is None:
            return False

        # Tentar serializar o gr√°fico para verificar se est√° √≠ntegro
        chart_fig.to_json()
        return True
    except Exception:
        return False


def display_code_with_streamlit_suggestion(code, auto_execute=True):
    """Exibe c√≥digo Python com op√ß√£o de execu√ß√£o na pr√≥pria interface."""
    st.code(code, language='python')

    if auto_execute:
        st.info("üí° **C√≥digo Gerado:** Este c√≥digo ser√° executado automaticamente na pr√≥pria interface!")

        # Expander para mostrar que o c√≥digo est√° sendo executado
        with st.expander("üîÑ Executando c√≥digo automaticamente...", expanded=True):
            st.markdown("**Status:** Executando c√≥digo Python gerado...")

            # Simular execu√ß√£o (iremos implementar a execu√ß√£o real no app.py)
            execution_container = st.empty()

            # Placeholder para resultados da execu√ß√£o
            st.markdown("**Resultados da Execu√ß√£o:**")
            results_container = st.empty()

            # Retornar os containers para serem atualizados pelo app.py
            return execution_container, results_container

    # Quando auto_execute=False, apenas exibe o c√≥digo sem containers
    return None, None